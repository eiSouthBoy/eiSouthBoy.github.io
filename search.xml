<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ssh remote login</title>
    <url>/2024/08/21/ssh%20remote%20login/</url>
    <content><![CDATA[<h2 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h2><p>一般都是在本地PC通过ssh远程连接服务器，在本地PC基本都有ssh client程序，而服务器不一定会有ssh server程序。所以首先第一步要确认服务器是否已经安装了ssh server程序（即openssh-server），若已经安装，则跳过；若没有安装，则接下来安装步骤。</p>
<ul>
<li><p>服务器上检查是否安装 openssh-server</p>
<p>可以通过如下命令查询：<code>dpkg -l | grep openssh-server</code></p>
</li>
<li><p>服务器上安装openssh-server</p>
<p>可以通过如下命令安装：<code>sudo apt update &amp;&amp; sudo apt install openssh-server</code></p>
</li>
<li><p>服务器上检查sshd服务是否启动</p>
<p>可以通过几种方式去查询，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1</span></span><br><span class="line">ps -ef | grep sshd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line">systemctl status ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式3</span></span><br><span class="line">service ssh status</span><br></pre></td></tr></table></figure>

<p>若服务没有启动，则可以通过几种方式去启动，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 方式1</span></span><br><span class="line">systtemctl start ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式2</span></span><br><span class="line">service ssh start</span><br></pre></td></tr></table></figure></li>
</ul>
<p>至此，在服务器上安装ssh（即openssh-server）完成。</p>
<h2 id="登录ssh"><a href="#登录ssh" class="headerlink" title="登录ssh"></a>登录ssh</h2><p>在服务器上安装ssh后，可以在本地PC通过连接到服务器ssh，登录的方式有：秘钥登录 和 公钥登录。</p>
<h3 id="秘钥登录"><a href="#秘钥登录" class="headerlink" title="秘钥登录"></a>秘钥登录</h3><p>秘钥登录就是通过用户名和密码进行登录，例如通过秘钥登录到树莓派（作为服务器角色）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># raspberry是树莓派的主机名，也可以替换为树莓派的IP地址。执行命令后，会要求输入pi用户的密码。</span></span><br><span class="line">ssh pi@raspberry</span><br></pre></td></tr></table></figure>



<h3 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h3><p>公钥登录是指将本地PC的公钥上传到服务器上，本地PC将登录信息用私钥签名给服务器，服务器用本地PC的公钥鉴别。</p>
<ul>
<li><p>本地PC创建公钥</p>
<p>通过命令创建公钥：<code>ssh-keygen</code>，接下来一路回车即可创建完成。</p>
<p>秘钥生成的文件：<code>~/.ssh/id_rsa.pub</code> 和 <code>~/.ssh/id_rsa</code></p>
</li>
<li><p>上传公钥到服务器</p>
<p>通过命令将公钥上传到服务器，可以使用如下命令：<code>cd ~/.ssh &amp;&amp; scp id_rsa.pub pi@raspberry:/home/pi</code></p>
</li>
<li><p>服务器修改ssh配置</p>
<p>先在服务器创建 <code>~/.ssh/authorized_keys</code>，然后将本地PC的公钥写进入。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件</span></span><br><span class="line"><span class="built_in">mkdir</span> /home/pi/.ssh </span><br><span class="line"><span class="built_in">touch</span> /home/pi/.ssh/authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 公钥写入</span></span><br><span class="line"><span class="built_in">cd</span> /home/pi/.ssh</span><br><span class="line"><span class="built_in">cat</span> /home/pi/id_rsa.pub &gt;&gt; authorized_keys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改文件权限</span></span><br><span class="line"><span class="built_in">chmod</span> 600 authorized_keys</span><br></pre></td></tr></table></figure>

<p>最后修改ssh的配置文件：<code>/etc/ssh/sshd_config</code>，涉及到的选项有：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 公钥登录许可</span></span><br><span class="line">PubkeyAuthentication <span class="built_in">yes</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>公钥登录</p>
<p>修改完ssh服务的配置文件后，重启ssh服务，接着本地PC通过公钥登录服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重启ssh服务 方式1</span></span><br><span class="line">systemctl restart ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># # 重启ssh服务 方式2</span></span><br><span class="line">service ssh restart</span><br></pre></td></tr></table></figure></li>
</ul>
<p>本地PC通过ssh公钥认证登录：<code>ssh pi@raspberry</code>，此时会直接登录，无需密码。</p>
<p>登录成功提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">eiSouthBoy@eiSouthBoy-NMH-WCX9:~$ ssh  pi@raspberry</span><br><span class="line">Welcome to Ubuntu 24.04 LTS (GNU/Linux 6.8.0-1009-raspi aarch64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https://help.ubuntu.com</span><br><span class="line"> * Management:     https://landscape.canonical.com</span><br><span class="line"> * Support:        https://ubuntu.com/pro</span><br><span class="line"></span><br><span class="line">Expanded Security Maintenance <span class="keyword">for</span> Applications is not enabled.</span><br><span class="line"></span><br><span class="line">0 updates can be applied immediately.</span><br><span class="line"></span><br><span class="line">Enable ESM Apps to receive additional future security updates.</span><br><span class="line">See https://ubuntu.com/esm or run: <span class="built_in">sudo</span> pro status</span><br><span class="line"></span><br><span class="line">*** System restart required ***</span><br><span class="line">Last login: Thu Aug 22 11:10:19 2024 from fdfc:869c:9ebb:0:2803:5d58:2f66:5d78</span><br><span class="line"></span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title>Shell and Shell Scripts</title>
    <url>/2024/08/18/Shell%20and%20Shell%20Scripts/</url>
    <content><![CDATA[<h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>在Linux中有很多Shell可以使用，常用的有如下：</p>
<ul>
<li>sh：即Bourne shell，由Steven Bourne开发，这是第一个流行的shell</li>
<li>bash：即Bourne Again Shell，由GNU组织开发，属于Bourne shell的增强版本，这是Linux默认使用的shell</li>
<li>csh：即C shell，由Bill Joy开发，这是流行于学术界Sun主机的shell</li>
</ul>
<p>虽然shell有很多种，但是学习和工作都是基于Linux，所以掌握bash即可。</p>
<h3 id="bash的功能"><a href="#bash的功能" class="headerlink" title="bash的功能"></a>bash的功能</h3><ul>
<li>历史命令记录（history）</li>
<li>命令补全功能（bash-completion）</li>
<li>命令别名设置（alias）</li>
<li>shell脚本执行（shell scripts）</li>
</ul>
<h3 id="bash的命令分类"><a href="#bash的命令分类" class="headerlink" title="bash的命令分类"></a>bash的命令分类</h3><p>在bash中执行的命令分为两种类型：</p>
<ul>
<li><p>内置命令：内置命令是指集成在bash里面的可以执行的文件，例如：cd、pwd</p>
</li>
<li><p>外部命令：外部命令是文件系统里的可执行文件，例如用户下载的软件和编写的脚本文件</p>
</li>
</ul>
<blockquote>
<p>如何在bash中判断命令的类型？type target-command</p>
</blockquote>
<p>如果target-command是一个内置命令，则会打印如下信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">target-command is a shell <span class="built_in">builtin</span></span><br></pre></td></tr></table></figure>

<p><em>注意：使用时，将target-command替换具体的命令，例如：cd、ls</em></p>
<h3 id="bash的技巧"><a href="#bash的技巧" class="headerlink" title="bash的技巧"></a>bash的技巧</h3><p>在使用bash中有很多常用的小技巧或者小功能，有必要学习和记录一下。</p>
<ul>
<li>命令换行：输入一行命令太长，阅读效果并不好，需要拆分成多行显示。在需要换行位置输入 <code>\</code> ，紧接着按下回车键（Enter），然后接着输入未完成的命令。</li>
<li>光标跳转：输入一行命令后，发现行头附近有错误或者行尾处有错误，需要快速跳转到行头或行尾。通过组合键进行光标快速跳转，<code>Ctrl+A</code> 调到行头，<code>Ctrl+E</code> 跳到行尾</li>
<li>环境变量：bash中有很多默认的环境变量，所以很多部命令不需要输入绝对路径就可以执行。通过 <code>env</code> 可以查询所有的默认环境变量。</li>
</ul>
<h2 id="Shell-Scripts"><a href="#Shell-Scripts" class="headerlink" title="Shell Scripts"></a>Shell Scripts</h2><blockquote>
<p>shell scripts是什么？</p>
</blockquote>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Shell</tag>
        <tag>Shell Scripts</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>bluetoothctl client tool</title>
    <url>/2024/08/16/bluetoothctl%20client%20tool/</url>
    <content><![CDATA[<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在使用某一家SoC的蓝牙库的时候，很多东西都无法修改。但是在测试的过程中，发现这家SoC的蓝牙库也是基于bluez的dbus实现的，那么我也可以封装一个蓝牙库。</p>
<p>首先，我手里有树莓派4B一台，该设备具备了蓝牙和Wi-Fi功能。那么只需要通过研究bluez项目中的bluetoothctl工具的源码，然后进行自定义修改，最后封装成自己的蓝牙库。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="硬件平台"><a href="#硬件平台" class="headerlink" title="硬件平台"></a>硬件平台</h3><p>树莓派环境介绍：</p>
<blockquote>
<p>系统：Ubuntu 24.04 LTS</p>
<p>内核：6.8.0-1009-raspi</p>
<p>架构：aarch64</p>
<p>内存：8GB</p>
</blockquote>
<p>阅读蓝牙官方文档，通过基于bluez的dbus接口编程需要相关依赖库：glib-2.0 、gio-2.0、 dbus-1，如果树莓派环境没有以上依赖库，则通过apt安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install libglib2.0-dev libdbus-1-dev</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过pkg-config可以查找对应的头文件目录和库文件</span></span><br><span class="line">pkg-config --cflags glib-2.0 gio-2.0 dbus-1</span><br><span class="line">pkg-config --libs glib-2.0 gio-2.0 dbus-1</span><br></pre></td></tr></table></figure>

<p>涉及的头文件目录和库文件有如下：</p>
<ul>
<li><p>-I&#x2F;usr&#x2F;include&#x2F;glib-2.0 </p>
</li>
<li><p>-I&#x2F;usr&#x2F;lib&#x2F;aarch64-linux-gnu&#x2F;glib-2.0&#x2F;include </p>
</li>
<li><p>-pthread -I&#x2F;usr&#x2F;include&#x2F;libmount</p>
</li>
<li><p>-I&#x2F;usr&#x2F;include&#x2F;blkid </p>
</li>
<li><p>-lgio-2.0 </p>
</li>
<li><p>-lgobject-2.0 </p>
</li>
<li><p>-lglib-2.0 </p>
</li>
<li><p>-ldbus-1</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过dpkg查看相关依赖库是否已经安装</span></span><br><span class="line">dpkg -l | grep libglib2.0-dev</span><br><span class="line">dpkg -l | grep libdbus-1-dev</span><br></pre></td></tr></table></figure>

<p>涉及的依赖包有如下：</p>
<ul>
<li><p>libglib2.0-dev-bin</p>
</li>
<li><p>libglib2.0-dev-bin</p>
</li>
<li><p>libdbus-1-dev:arm64</p>
</li>
</ul>
<h3 id="协议文档"><a href="#协议文档" class="headerlink" title="协议文档"></a>协议文档</h3><h4 id="dbus数据模型"><a href="#dbus数据模型" class="headerlink" title="dbus数据模型"></a>dbus数据模型</h4><p><a href="https://dbus.freedesktop.org/doc/dbus-specification.html">dbus规范</a></p>
<p>dbus使用一套类型于JSON类型的数据模型，但还是有所差别，dbus数据模型：</p>
<table>
<thead>
<tr>
<th>常规名字</th>
<th>ASCII符号</th>
<th>编码存储</th>
</tr>
</thead>
<tbody><tr>
<td>BYTE</td>
<td>y</td>
<td>unsigned 8-bit integer</td>
</tr>
<tr>
<td>BOOlEAN</td>
<td>b</td>
<td>boolean value: 0 is false, 1 is true</td>
</tr>
<tr>
<td>INT16</td>
<td>n</td>
<td>signed 16-bit integer</td>
</tr>
<tr>
<td>UINT16</td>
<td>q</td>
<td>unsigned 16-bit integer</td>
</tr>
<tr>
<td>INT32</td>
<td>i</td>
<td>signed 32-bit integer</td>
</tr>
<tr>
<td>UINT32</td>
<td>u</td>
<td>unsigned 32-bit integer</td>
</tr>
<tr>
<td>INT64</td>
<td>x</td>
<td>signed 64-bit integer</td>
</tr>
<tr>
<td>UINT64</td>
<td>t</td>
<td>unsigned 64-bit integer</td>
</tr>
<tr>
<td>DOUBLE</td>
<td>d</td>
<td>double-precision floating point</td>
</tr>
<tr>
<td>UNIX_FD</td>
<td>h</td>
<td>unsigned 32-bit representing an index into an out-of-band array of file descriptors</td>
</tr>
<tr>
<td>STRING</td>
<td>s</td>
<td>string, 必须是有效的UTF-8字符串</td>
</tr>
<tr>
<td>OBJECT_PATH</td>
<td>o</td>
<td>object_path，例如：&#x2F;org&#x2F;bluez&#x2F;hci0&#x2F;dev_50_64_2B_BF_46_36</td>
</tr>
<tr>
<td>SIGNATURE</td>
<td>g</td>
<td>signature类型，即签名类型</td>
</tr>
<tr>
<td>ARRAY</td>
<td>a</td>
<td>array, like []</td>
</tr>
<tr>
<td>VARIANT</td>
<td>v</td>
<td>variant，变体类型</td>
</tr>
<tr>
<td>STRUCT</td>
<td>r 、(  、 )</td>
<td>结构类型</td>
</tr>
<tr>
<td>DICT_ENTRY</td>
<td>e 、{ 、 }</td>
<td>字典或映射（键值对数组）的条目</td>
</tr>
</tbody></table>
<h4 id="dbus接口模型"><a href="#dbus接口模型" class="headerlink" title="dbus接口模型"></a>dbus接口模型</h4><ul>
<li><p><strong>服务名称（dbus name）</strong>：<br>服务端程序在D-Bus上注册的服务名称（即 dbus name），在D-Bus上的注册的服务后会产生一个地址（例如：<code>/org/bluez</code>）和唯一名称（例如：<code>1.466</code>），地址和唯一名称都是随机生成的，客户端通过dbus name来知道服务名称。dbus name的格式，例如：<code>org.bluez</code>，这是D-Bus的规定，没有为什么。</p>
</li>
<li><p><strong>对象（Object）</strong>：<br>对象以路径的形式表示，对象路径代表一个对象实例。对象路径的前缀以dbus name为参考，接上其他的。例如，上述dbus name：<code>org.bluez</code>，那么对象路径前缀是：<code>/org/bluez</code>，接上其他的，形成完成的对象路径，例如：<code>/org/bluez/hci0</code></p>
</li>
<li><p><strong>接口（Interface）</strong>：<br>接口，顾名思义。接口名称的格式规定与dbus name一样，例如：<code>org.bluez.Adapter1</code></p>
</li>
<li><p><strong>成员名称（Member name）</strong>：<br>成员包括：方法（Method）和信号（Signal），在大多数方面，他们几乎是一样的，除了两点：</p>
<p>1、Signal是在总线中进行广播的，而Method是指定发给某个进程的。</p>
<p>2、Signal 不会有返回，而 Method 一定会有返回（Method调用可以同步的或是异步的）。</p>
<p>从 C API 的层面来看，Member name 最大的作用就是在两个进程间共享 “发出的消息的类型信息”，DBus 只能以 Signal or Method 来进行消息通信。</p>
</li>
</ul>
<h4 id="dbus通用接口"><a href="#dbus通用接口" class="headerlink" title="dbus通用接口"></a>dbus通用接口</h4><p>dbus标准接口共有4个，分别是：</p>
<ul>
<li>org.freedesktop.DBus.Peer</li>
<li>org.freedesktop.DBus.Introspectable</li>
<li><strong>org.freedesktop.DBus.Properties</strong>：用于获取和设置对象属性，并监听属性变化。</li>
<li><strong>org.freedesktop.DBus.ObjectManager</strong>：用于管理和监控 D-Bus 对象，通常用于获取所有对象及其接口和属性。</li>
</ul>
<h5 id="org-freedesktop-DBus-Properties"><a href="#org-freedesktop-DBus-Properties" class="headerlink" title="org.freedesktop.DBus.Properties"></a>org.freedesktop.DBus.Properties</h5><p>常用的方法有：</p>
<ul>
<li>Get：获取对象的特定属性值</li>
<li>Set：设置对象的特定属性值</li>
<li>GetAll：获取对象的所有属性值</li>
</ul>
<p>常用的信号有：</p>
<ul>
<li>PropertiesChanged：当对象的属性发生变化时发出信号</li>
</ul>
<h5 id="org-freedesktop-DBus-ObjectManager"><a href="#org-freedesktop-DBus-ObjectManager" class="headerlink" title="org.freedesktop.DBus.ObjectManager"></a>org.freedesktop.DBus.ObjectManager</h5><p>常用的方法有：</p>
<ul>
<li>GetManagedObjects：获取所有受管理的对象及其接口和属性</li>
</ul>
<p>常用的信号有：</p>
<ul>
<li><p>InterfacesAdded：当新对象添加时发出信号</p>
</li>
<li><p>InterfacesRemoved：当对象接口移除时发出信号</p>
</li>
</ul>
<h4 id="dbus-for-bluez接口"><a href="#dbus-for-bluez接口" class="headerlink" title="dbus for bluez接口"></a>dbus for bluez接口</h4><p>bluez dbus api 文档涉及到各个不同接口，主要关注这几个接口：</p>
<ul>
<li>org.bluez.Adapter1</li>
<li>org.bluez.Device1</li>
<li>org.bluez.Agent1</li>
</ul>
<h5 id="org-bluez-Adapter1"><a href="#org-bluez-Adapter1" class="headerlink" title="org.bluez.Adapter1"></a>org.bluez.Adapter1</h5><p><strong>接口介绍：</strong></p>
<p>这个接口用于管理蓝牙适配器，实现了蓝牙设备的搜索和管理功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:Service:	org.bluez</span><br><span class="line">:Interface:	org.bluez.Adapter1</span><br><span class="line">:Object path:	[variable prefix]/&#123;hci0,hci1,...&#125;</span><br></pre></td></tr></table></figure>

<p><strong>方法介绍：</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>void StartDiscovery()</strong></td>
<td>开始扫描设备</td>
</tr>
<tr>
<td><strong>void StopDiscovery()</strong></td>
<td>结束扫描设备</td>
</tr>
<tr>
<td><strong>void RemoveDevice(object device)</strong></td>
<td>移除蓝牙设备</td>
</tr>
<tr>
<td>void SetDiscoveryFilter(dict filter)</td>
<td>设置扫描条件</td>
</tr>
<tr>
<td>array{string} GetDiscoveryFilters()</td>
<td>获取扫描条件</td>
</tr>
<tr>
<td>object ConnectDevice(dict properties) [experimental]</td>
<td>连接蓝牙设备</td>
</tr>
</tbody></table>
<p><strong>属性介绍：</strong></p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>string Address</strong></td>
<td>[readonly]</td>
<td>蓝牙设备MAC地址</td>
</tr>
<tr>
<td>string AddressType</td>
<td>[readonly]</td>
<td>取值范围：public和random</td>
</tr>
<tr>
<td><strong>string Name</strong></td>
<td>[readonly]</td>
<td>蓝牙设备名称</td>
</tr>
<tr>
<td>string Alias</td>
<td>[readwrite]</td>
<td>蓝牙设备别名</td>
</tr>
<tr>
<td>uint32 Class</td>
<td>[readonly]</td>
<td>蓝牙设备类型</td>
</tr>
<tr>
<td><strong>boolean Powered</strong></td>
<td>[readwrite]</td>
<td>打开或关闭适配器电源</td>
</tr>
<tr>
<td>string PowerState</td>
<td>[readonly, experimental]</td>
<td>适配器电源状态</td>
</tr>
<tr>
<td>boolean Discoverable</td>
<td>[readwrite] (Default: false)</td>
<td>打开或关闭适配器可被发现状态</td>
</tr>
<tr>
<td>boolean Pairable</td>
<td>[readwrite] (Default: true)</td>
<td>打开或关闭适配可被配对状态</td>
</tr>
<tr>
<td>uint32 PairableTimeout</td>
<td>[readwrite] (Default: 0)</td>
<td>配对超时时间（单位：秒）</td>
</tr>
<tr>
<td>uint32 DiscoverableTimeout</td>
<td>[readwrite] (Default: 180)</td>
<td>发现超时时间（单位：秒）</td>
</tr>
<tr>
<td>boolean Discovering</td>
<td>[readonly]</td>
<td>扫描执行状态</td>
</tr>
<tr>
<td>array{string} UUIDs</td>
<td>[readonly]</td>
<td>128-bit UIIDs</td>
</tr>
<tr>
<td>string Modalias</td>
<td>[readonly, optional]</td>
<td>内核使用的本地设备ID</td>
</tr>
<tr>
<td>array{string} Roles</td>
<td>[readonly]</td>
<td>支持角色列表</td>
</tr>
<tr>
<td>array{string} ExperimentalFeatures</td>
<td>[readonly, optional]</td>
<td>实验性质的128-bit UIIDs</td>
</tr>
<tr>
<td>uint16 Manufacturer</td>
<td>[readonly]</td>
<td>设备制造商</td>
</tr>
<tr>
<td>byte Version</td>
<td>[readonly]</td>
<td>设备支持的蓝牙版本</td>
</tr>
</tbody></table>
<h5 id="org-bluez-Device1"><a href="#org-bluez-Device1" class="headerlink" title="org.bluez.Device1"></a>org.bluez.Device1</h5><p><strong>接口介绍：</strong></p>
<p>这个接口用于管理蓝牙设备，实现了设备的配对、连接和断开连接等功能。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:Service:	org.bluez</span><br><span class="line">:Interface:	org.bluez.Device1</span><br><span class="line">:Object path:	[variable prefix]/&#123;hci0,hci1,...&#125;/dev_XX_XX_XX_XX_XX_XX</span><br></pre></td></tr></table></figure>

<p><strong>方法介绍：</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><strong>void Connect()</strong></td>
<td>连接蓝牙设备</td>
</tr>
<tr>
<td><strong>void Disconnect()</strong></td>
<td>断开蓝牙设备</td>
</tr>
<tr>
<td>void ConnectProfile(string uuid)</td>
<td>连接配置文件</td>
</tr>
<tr>
<td>void DisconnectProfile(string uuid)</td>
<td>断开配置文件</td>
</tr>
<tr>
<td><strong>void Pair()</strong></td>
<td>配对蓝牙设备</td>
</tr>
<tr>
<td>void CancelPairing()</td>
<td>取消配对请求</td>
</tr>
</tbody></table>
<p><strong>属性介绍：</strong></p>
<table>
<thead>
<tr>
<th>属性名称</th>
<th>权限</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>string Address</strong></td>
<td>[readonly]</td>
<td>蓝牙设备MAC地址</td>
</tr>
<tr>
<td>string AddressType</td>
<td>[readonly]</td>
<td>取值范围：public和random</td>
</tr>
<tr>
<td><strong>string Name</strong></td>
<td>[readonly, optional]</td>
<td>蓝牙设备名称</td>
</tr>
<tr>
<td>string Icon</td>
<td>[readonly, optional]</td>
<td>蓝牙设备图标</td>
</tr>
<tr>
<td>uint32 Class</td>
<td>[readonly, optional]</td>
<td>蓝牙设备类型</td>
</tr>
<tr>
<td>uint16 Appearance</td>
<td>[readonly, optional]</td>
<td>蓝牙设备外观</td>
</tr>
<tr>
<td>array{string} UUIDs</td>
<td>[readonly, optional]</td>
<td>128-bit UIIDs</td>
</tr>
<tr>
<td><strong>boolean Paired</strong></td>
<td>[readonly]</td>
<td>蓝牙设备配对状态</td>
</tr>
<tr>
<td>boolean Bonded</td>
<td>[readonly]</td>
<td>蓝牙设备绑定状态</td>
</tr>
<tr>
<td><strong>boolean Connected</strong></td>
<td>[readonly]</td>
<td>蓝牙设备连接状态</td>
</tr>
<tr>
<td>boolean Trusted</td>
<td>[readwrite]</td>
<td>蓝牙设备信任状态</td>
</tr>
<tr>
<td>boolean Blocked</td>
<td>[readwrite]</td>
<td>蓝牙设备阻塞状态</td>
</tr>
<tr>
<td>boolean WakeAllowed</td>
<td>[readwrite]</td>
<td>蓝牙设备唤醒功能</td>
</tr>
<tr>
<td>string Alias</td>
<td>[readwrite]</td>
<td>蓝牙设备别名</td>
</tr>
<tr>
<td>object Adapter</td>
<td>[readonly]</td>
<td>蓝牙设备所属适配器对象</td>
</tr>
<tr>
<td>boolean LegacyPairing</td>
<td>[readonly]</td>
<td>传统配对功能</td>
</tr>
<tr>
<td>string Modalias</td>
<td>[readonly, optional]</td>
<td>内核使用的设备ID</td>
</tr>
<tr>
<td>int16 RSSI</td>
<td>[readonly, optional]</td>
<td>蓝牙设备信号强度</td>
</tr>
<tr>
<td>int16 TxPower</td>
<td>[readonly, optional]</td>
<td>蓝牙广播发射功率电平</td>
</tr>
<tr>
<td>dict ManufacturerData</td>
<td>[readonly, optional]</td>
<td>蓝牙制造商数据</td>
</tr>
<tr>
<td>dict ServiceData</td>
<td>[readonly, optional]</td>
<td>蓝牙服务数据</td>
</tr>
<tr>
<td>bool ServicesResolved</td>
<td>[readonly]</td>
<td>服务解析是否完成</td>
</tr>
<tr>
<td>array{byte} AdvertisingFlags</td>
<td>[readonly]</td>
<td>蓝牙广播数据标志</td>
</tr>
<tr>
<td>dict AdvertisingData</td>
<td>[readonly]</td>
<td>蓝牙广播数据</td>
</tr>
<tr>
<td>array{object, dict} Sets</td>
<td>[readonly, experimental]</td>
<td>蓝牙设备所属对象集合</td>
</tr>
</tbody></table>
<h5 id="org-bluez-Agent1"><a href="#org-bluez-Agent1" class="headerlink" title="org.bluez.Agent1"></a>org.bluez.Agent1</h5><p><strong>接口介绍：</strong></p>
<p>这个用于管理蓝牙代理，实现了蓝牙认证和授权功能。在进行蓝牙配对时，代理程序将被调用执行认证和授权操作。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">:Service:	unique name</span><br><span class="line">:Interface:	org.bluez.Agent1</span><br><span class="line">:Object path:	freely definable</span><br></pre></td></tr></table></figure>

<p><strong>方法介绍：</strong></p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>void Release()</td>
<td>释放任务</td>
</tr>
<tr>
<td>string RequestPinCode(object device)</td>
<td>请求PIN码</td>
</tr>
<tr>
<td>void DisplayPinCode(object device, string pincode)</td>
<td>显示PIN码</td>
</tr>
<tr>
<td>uint32 RequestPasskey(object device)</td>
<td>请求秘钥</td>
</tr>
<tr>
<td>void DisplayPasskey(object device, uint32 passkey, uint16 entered)</td>
<td>显示秘钥</td>
</tr>
<tr>
<td>void RequestConfirmation(object device, uint32 passkey)</td>
<td>请求确认秘钥</td>
</tr>
<tr>
<td>void RequestAuthorization(object device)</td>
<td>请求授权</td>
</tr>
<tr>
<td>void AuthorizeService(object device, string uuid)</td>
<td>授权服务</td>
</tr>
<tr>
<td>void Cancel()</td>
<td>取消请求</td>
</tr>
</tbody></table>
<p><strong>属性介绍：</strong></p>
<p>无属性</p>
<h4 id="gdbus接口"><a href="#gdbus接口" class="headerlink" title="gdbus接口"></a>gdbus接口</h4><p>gio库提供了对于dbus接口的高级封装：<a href="https://docs.gtk.org/gio/index.html">gdbus</a>，常用API总结，方便直接定位查寻：</p>
<p><a href="https://docs.gtk.org/gio/func.bus_get_sync.html">g_bus_get_sync()</a></p>
<p>描述：同步连接到bus_type指定的消息总线。若返回值为NULL，则错误发生；若返回值不为NULL，调用者有责任使用 <code>g_object_unref()</code> 释放返回值。当调用错误发生时，<code>error != NULL</code>，可以通过error知道错误的原因，调用者有责任使用 <code>g_error_free()</code> 释放error。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GDBusConnection*</span><br><span class="line"><span class="title function_">g_bus_get_sync</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GBusType bus_type,</span></span><br><span class="line"><span class="params">  GCancellable* cancellable,</span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/ctor.MainLoop.new.html">g_main_loop_new()</a></p>
<p>描述：创建一个新的GMainLoop结构体，调用者有责任去释放这个结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GMainLoop*</span><br><span class="line"><span class="title function_">g_main_loop_new</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GMainContext* context,</span></span><br><span class="line"><span class="params">  gboolean is_running</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/gobject/method.Object.unref.html">g_object_unref()</a></p>
<p>描述：减少对象的参考计数。当其参考计数降至0时，对象将最终确定（即其内存已释放）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">g_object_unref</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GObject* object</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>



<p><a href="https://docs.gtk.org/glib/method.MainLoop.run.html">g_main_loop_run()</a></p>
<p>描述：运行主循环，直到 g_main_loop_quit() 被调用才结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">g_main_loop_run</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GMainLoop* loop</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>



<p><a href="https://docs.gtk.org/gio/type_func.DBusProxy.new.html">g_dbus_proxy_new()</a></p>
<p>描述：创建一个代理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">g_dbus_proxy_new</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GDBusConnection* connection,</span></span><br><span class="line"><span class="params">  GDBusProxyFlags flags,</span></span><br><span class="line"><span class="params">  GDBusInterfaceInfo* info,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* name,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* object_path,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* interface_name,</span></span><br><span class="line"><span class="params">  GCancellable* cancellable,</span></span><br><span class="line"><span class="params">  GAsyncReadyCallback callback,</span></span><br><span class="line"><span class="params">  gpointer user_data</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>



<p><a href="https://docs.gtk.org/gio/method.DBusProxy.call.html">g_dbus_proxy_call()</a></p>
<p>描述：异步调用代理上的 method_name 方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">g_dbus_proxy_call</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GDBusProxy* proxy,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* method_name,</span></span><br><span class="line"><span class="params">  GVariant* parameters,</span></span><br><span class="line"><span class="params">  GDBusCallFlags flags,</span></span><br><span class="line"><span class="params">  gint timeout_msec,</span></span><br><span class="line"><span class="params">  GCancellable* cancellable,</span></span><br><span class="line"><span class="params">  GAsyncReadyCallback callback,</span></span><br><span class="line"><span class="params">  gpointer user_data</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="">g_dbus_proxy_call_sync()</a></p>
<p>描述：同步调用<code>method_name</code>上的方法<code>proxy</code> ，调用线程被阻塞，直到收到回复。若返回值为NULL，则错误发生；若返回值不为NULL，调用者有责任使用 <code>g_variant_unref()</code> 去释放返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GVariant*</span><br><span class="line"><span class="title function_">g_dbus_proxy_call_sync</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GDBusProxy* proxy,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* method_name,</span></span><br><span class="line"><span class="params">  GVariant* parameters,</span></span><br><span class="line"><span class="params">  GDBusCallFlags flags,</span></span><br><span class="line"><span class="params">  gint timeout_msec,</span></span><br><span class="line"><span class="params">  GCancellable* cancellable,</span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>



<p><a href="https://docs.gtk.org/gio/method.DBusConnection.call_sync.html">g_dbus_connection_call_sync()</a></p>
<p>描述：同步调用bus_name 拥有的object_path 远程对象上interface_name D-Bus 接口上的method_name 方法。当返回值为NULL，则有错误发生。若返回值不为NULL，调用有责任通过 g_variant_unref() 去释放它。该函数被调用时，线程被阻塞，直到收到回复。</p>
<p>若 <code>error != NULL</code> 说明错误发生，调用者有责任去释放error。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GVariant*</span><br><span class="line"><span class="title function_">g_dbus_connection_call_sync</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GDBusConnection* connection,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* bus_name,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* object_path,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* interface_name,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* method_name,</span></span><br><span class="line"><span class="params">  GVariant* parameters,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> GVariantType* reply_type,</span></span><br><span class="line"><span class="params">  GDBusCallFlags flags,</span></span><br><span class="line"><span class="params">  gint timeout_msec,</span></span><br><span class="line"><span class="params">  GCancellable* cancellable,</span></span><br><span class="line"><span class="params">  GError** error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/gio/method.DBusConnection.call.html">g_dbus_connection_call()</a></p>
<p>描述：异步调用bus_name 拥有的object_path 远程对象上interface_name D-Bus 接口上的method_name 方法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">g_dbus_connection_call</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GDBusConnection* connection,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* bus_name,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* object_path,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* interface_name,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* method_name,</span></span><br><span class="line"><span class="params">  GVariant* parameters,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> GVariantType* reply_type,</span></span><br><span class="line"><span class="params">  GDBusCallFlags flags,</span></span><br><span class="line"><span class="params">  gint timeout_msec,</span></span><br><span class="line"><span class="params">  GCancellable* cancellable,</span></span><br><span class="line"><span class="params">  GAsyncReadyCallback callback,</span></span><br><span class="line"><span class="params">  gpointer user_data</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/gio/method.DBusConnection.call_finish.html">g_dbus_connection_call_finish()</a></p>
<p>描述：完成由 g_dbus_connection_call() 启动的操作。若返回值为NULL，则错误发生。当返回值不为NULL，调用者有责任通过 g_variant_unref() 去释放它。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GVariant*</span><br><span class="line">g_dbus_connection_call_finish (</span><br><span class="line">  GDBusConnection* connection,</span><br><span class="line">  GAsyncResult* res,</span><br><span class="line">  GError** error</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/gio/method.DBusConnection.signal_subscribe.html">g_dbus_connection_signal_subscribe()</a></p>
<p>描述：在connection上订阅信号，当信号被接收时调用回调函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">guint</span><br><span class="line"><span class="title function_">g_dbus_connection_signal_subscribe</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GDBusConnection* connection,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* sender,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* interface_name,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* member,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* object_path,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* arg0,</span></span><br><span class="line"><span class="params">  GDBusSignalFlags flags,</span></span><br><span class="line"><span class="params">  GDBusSignalCallback callback,</span></span><br><span class="line"><span class="params">  gpointer user_data,</span></span><br><span class="line"><span class="params">  GDestroyNotify user_data_free_func</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="">g_variant_get()</a></p>
<p>描述：解构一个<code>GVariant</code>实例，其功能类似 <code>scanf()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">g_variant_get</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariant* value,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* format_string,</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>



<p><a href="https://docs.gtk.org/glib/method.Variant.get_child_value.html">g_variant_get_child_value()</a></p>
<p>描述：从容器 GVariant 实例中读取子项。这包括variants、maybes、arrays、tuples和dictionary entries。在任何其他类型的 GVariant 上调用此函数都是错误的。调用者有责任使用 g_variant_unref() 去释放它（返回值）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GVariant*</span><br><span class="line"><span class="title function_">g_variant_get_child_value</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariant* value,</span></span><br><span class="line"><span class="params">  gsize index_</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/method.VariantIter.init.html">g_variant_iter_init()</a></p>
<p>描述：初始化 GVariantIter 变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gsize</span><br><span class="line"><span class="title function_">g_variant_iter_init</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariantIter* iter,</span></span><br><span class="line"><span class="params">  GVariant* value</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/method.VariantIter.next.html">g_variant_iter_next()</a></p>
<p>描述：获取容器的下一项。若返回值为false，则该项没有值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gboolean</span><br><span class="line"><span class="title function_">g_variant_iter_next</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariantIter* iter,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* format_string,</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/ctor.Variant.new.html#:~:text=GVariant%2A%20g_variant_new%20%28const%20gchar%2A%20format_string%2C...%20%5B%20%E2%88%92%5D%20Description,expected%20by%20this%20function%20are%20determined%20by%20format_string.">g_variant_new()</a></p>
<p>描述：创建一个新的GVariant变量实例，若返回值不为NULL，调用者有责任去通过 <code>g_variant_unref</code> 释放它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GVariant*</span><br><span class="line"><span class="title function_">g_variant_new</span> <span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* format_string,</span></span><br><span class="line"><span class="params">  ...</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/ctor.Variant.new_object_path.html">g_variant_new_object_path()</a></p>
<p>描述：创建一个D-Bus对象路径的GVariant变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">GVariant*</span><br><span class="line"><span class="title function_">g_variant_new_object_path</span> <span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* object_path</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>





<p><a href="https://docs.gtk.org/glib/method.Variant.get_boolean.html">g_variant_get_boolean()</a></p>
<p>描述：返回value的gboolean值，取值范围：TRUE or FALSE</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gboolean</span><br><span class="line"><span class="title function_">g_variant_get_boolean</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariant* value</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>





<p><a href="https://docs.gtk.org/glib/func.strstr_len.html">g_strstr_len()</a></p>
<p>描述：其作用类似 strstr()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gchar*</span><br><span class="line"><span class="title function_">g_strstr_len</span> <span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* haystack,</span></span><br><span class="line"><span class="params">  gssize haystack_len,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* needle</span></span><br><span class="line"><span class="params">)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/func.ascii_strdown.html">g_ascii_strdown()</a></p>
<p>描述：其作用类似 tolower()</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gchar*</span><br><span class="line"><span class="title function_">g_ascii_strdown</span> <span class="params">(</span></span><br><span class="line"><span class="params">  <span class="type">const</span> gchar* str,</span></span><br><span class="line"><span class="params">  gssize len</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/method.Variant.get_string.html">g_variant_get_string()</a></p>
<p>描述：返回字符串类型的 GVariant 实例的字符串值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> gchar*</span><br><span class="line"><span class="title function_">g_variant_get_string</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariant* value,</span></span><br><span class="line"><span class="params">  gsize* length</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/method.Variant.get_type_string.html">g_variant_get_type_string()</a></p>
<p>描述：获取value值的类型字符串</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> gchar*</span><br><span class="line"><span class="title function_">g_variant_get_type_string</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariant* value</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/func.strcmp0.html">g_strcmp0()</a></p>
<p>描述：其作用类似 strcmp()</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int</span><br><span class="line">g_strcmp0 (</span><br><span class="line">  const char* str1,</span><br><span class="line">  const char* str2</span><br><span class="line">)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/method.Variant.get_type.html">g_variant_get_type()</a></p>
<p>描述：确认value的类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> GVariantType*</span><br><span class="line"><span class="title function_">g_variant_get_type</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariant* value</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/method.Variant.is_of_type.html">g_variant_is_of_type()</a></p>
<p>描述：检查值的类型是否与提供的类型匹配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gboolean</span><br><span class="line"><span class="title function_">g_variant_is_of_type</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariant* value,</span></span><br><span class="line"><span class="params">  <span class="type">const</span> GVariantType* type</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/func.printf.html">g_printf()</a></p>
<p>描述：其作用类似 printf()，glib提供一套类似于 <code>#include &lt;string.h&gt;</code> 的函数库<a href="https://docs.gtk.org/glib/string-utils.html#string-precision-pitfalls">String Utilities</a>，使用该函数库是必须显示的声明 <code>#include &lt;glib/gprintf.h&gt;</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gint</span><br><span class="line">g_printf (</span><br><span class="line">  const gchar* format,</span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/method.Variant.print.html">g_variant_print()</a></p>
<p>描述：将GVariant变量转换成字符串格式。若返回值不为NULL，调用者有责任释放返回值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">gchar*</span><br><span class="line"><span class="title function_">g_variant_print</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GVariant* value,</span></span><br><span class="line"><span class="params">  gboolean type_annotate</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>

<p><a href="https://docs.gtk.org/glib/method.Error.free.html">g_error_free()</a></p>
<p>描述：释放GError指向的内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">g_error_free</span> <span class="params">(</span></span><br><span class="line"><span class="params">  GError* error</span></span><br><span class="line"><span class="params">)</span></span><br></pre></td></tr></table></figure>





<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>在Ubuntu 24.04 LTS系统上可以下载 d-feet工具，可以UI形式显示协议文档中的那些接口，以便快速测试和实现蓝牙功能。</p>
<h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>根据前文预定的需求，逐个编写并测试功能API接口，最后完成自定义库的封装。</p>
<p>使用bluez进行蓝牙设备连接的流程：</p>
<p>1、蓝牙适配器设置为：power on</p>
<p>2、蓝牙适配器开始扫描</p>
<p>​	订阅 <code>org.freedesktop.DBus.Properties.PropertiesChanged</code> 信号监听接口属性变化</p>
<p>​	订阅 <code>org.freedesktop.DBus.ObjectManager.InterfacesAdded</code> 信号监听接口新增</p>
<p>​	订阅 <code>org.freedesktop.DBus.ObjectManager.InterfacesRemoved</code> 信号监听接口移除</p>
<p>​	调用 <code>org.bluez.Adapter1.StartDiscovery</code> 方法开始扫描附近蓝牙设备</p>
<p>3、蓝牙适配器配对蓝牙设备</p>
<p>​	在 <code>InterfacesAdded</code> 信号回调中，检查是否出现目标蓝牙设备</p>
<p>​	发现目标蓝牙设备后，调用 <code>org.bluez.Adapter1.StopDiscovery</code>，蓝牙适配器停止扫描</p>
<p>​	调用 <code>org.bluez.Device1.Pair</code> 方法进行配对蓝牙设备</p>
<p>​	调用 <code>org.freedesktop.DBus.ObjectManager.GetManagedObjects</code> 方法获取适配器配对状态 </p>
<p>4、连接设备</p>
<p>​	配对成功后，调用 <code>org.bluez.Device1.Connect</code> 方法连接蓝牙设备</p>
<p>​	调用 <code>org.freedesktop.DBus.ObjectManager.GetManagedObjects</code> 方法获取适配器连接状态 </p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/bluez/bluez">1、bluez on github</a></p>
<p><a href="https://www.bluez.org/">2、bluez with Official Linux Bluetooth protocol stack</a></p>
<p><a href="https://git.kernel.org/pub/scm/bluetooth/bluez.git/tree/doc/org.bluez.Adapter.rst">3、org.bluez.Adapter.rst</a></p>
<p><a href="https://git.kernel.org/pub/scm/bluetooth/bluez.git/tree/doc/org.bluez.Device.rst">4、org.bluez.Device.rst</a></p>
<p><a href="https://git.kernel.org/pub/scm/bluetooth/bluez.git/tree/doc/org.bluez.Agent.rst">5、org.bluez.Agent.rst</a></p>
<p><a href="https://dbus.freedesktop.org/doc/dbus-specification.html">6、D-Bus Specification</a></p>
<p><a href="https://github.com/nkim-bitzap/bluetooth/blob/master/connector/connector.c">7、github.com&#x2F;nkim-bitzap&#x2F;bluetooth</a></p>
]]></content>
      <categories>
        <category>bluetooth</category>
      </categories>
      <tags>
        <tag>bluetooth</tag>
        <tag>raspberry 4b</tag>
        <tag>bluez</tag>
        <tag>dbus</tag>
        <tag>gdbus</tag>
      </tags>
  </entry>
  <entry>
    <title>esp-matter：light project</title>
    <url>/2024/08/15/esp-matter%EF%BC%9Alight%20project/</url>
    <content><![CDATA[<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>拷贝 <code>~/esp/esp-matter/examples</code> 到指定目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> ~/esp/example-matter</span><br><span class="line"><span class="built_in">cp</span> -r ~/esp/esp-matter/examples/* ~/esp/example-matter</span><br><span class="line"><span class="built_in">cd</span> ~/esp/example-matter/light</span><br></pre></td></tr></table></figure>



<h3 id="设置目标"><a href="#设置目标" class="headerlink" title="设置目标"></a>设置目标</h3><p>开发板Soc是esp32-c3，故设置目标选择：esp32c3</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 激活esp-idf和esp-matter环境</span></span><br><span class="line">get_idf</span><br><span class="line">get_matter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标</span></span><br><span class="line">idf.py set-target esp32c3</span><br></pre></td></tr></table></figure>

<h3 id="编译固件"><a href="#编译固件" class="headerlink" title="编译固件"></a>编译固件</h3><p>直接开始编译固件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">idf.py build</span><br></pre></td></tr></table></figure>

<h3 id="烧录固件"><a href="#烧录固件" class="headerlink" title="烧录固件"></a>烧录固件</h3><p>将开发板插入PC的USB接口，修改串口权限，开始烧录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查找串口权限</span></span><br><span class="line"><span class="built_in">ls</span> -l /dev/ttyUSB0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改串口权限</span></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 664 /dev/ttyUSB0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 烧录固件</span></span><br><span class="line">idf.py -p /dev/ttyUSB0 flash</span><br></pre></td></tr></table></figure>



<h2 id="配网"><a href="#配网" class="headerlink" title="配网"></a>配网</h2><p>通过BLE方式给设备配网</p>
<p>启动Terminal A用于monitor串口数据，启动Terminal B用于执行chip-tool命令。其中chip-tool工具有两种使用方式：单次执行 和 交互执行。交互执行控制设备时，响应速度非常快，并且不容易产生超时报错。</p>
<p><strong>单次执行：</strong></p>
<p>单次执行配网命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chip-tool pairing ble-wifi 0x7283 CUBEC_AP_2.4G cubec2015 20202021 3840</span><br></pre></td></tr></table></figure>

<p><em>单次执行容易导致超时，建议使用交互执行！！！</em></p>
<p><strong>交互执行：</strong></p>
<p><strong>Terminal A</strong>处于等待配网状态，状态如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">I (1725) esp_matter_core: Dynamic endpoint 1 added</span><br><span class="line">I (1735) chip[DL]: WIFI_EVENT_STA_START</span><br><span class="line">W (1735) wifi:Haven<span class="string">&#x27;t to connect to a suitable AP now!</span></span><br><span class="line"><span class="string">I (1745) chip[DL]: Done driving station state, nothing else to do...</span></span><br><span class="line"><span class="string">I (1745) chip[DL]: Configuring CHIPoBLE advertising (interval 25 ms, connectable)</span></span><br><span class="line"><span class="string">I (1755) NimBLE: GAP procedure initiated: advertise; </span></span><br><span class="line"><span class="string">I (1765) NimBLE: disc_mode=2</span></span><br><span class="line"><span class="string">I (1765) NimBLE:  adv_channel_map=0 own_addr_type=1 adv_filter_policy=0 adv_itvl_min=40 adv_itvl_max=40</span></span><br><span class="line"><span class="string">I (1775) NimBLE: </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">I (1775) chip[DL]: CHIPoBLE advertising started</span></span><br><span class="line"><span class="string">I (1785) app_main: Commissioning window opened</span></span><br><span class="line"><span class="string">I (1855) main_task: Returned from app_main()</span></span><br><span class="line"><span class="string">&gt; I (4725) esp_matter_core: Store the deferred attribute 0x0 of cluster 0x8 on endpoint 0x1</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p><strong>Terminal B</strong>中执行命令：<code>chip-tool interactive start</code>，此时进入交互模式，状态如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  +-------------------------------------------------------------------------------------+</span><br><span class="line">  | Command sets:                                                                       |</span><br><span class="line">  +-------------------------------------------------------------------------------------+</span><br><span class="line">  | * any                                                                               |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> sending IM messages based on cluster <span class="built_in">id</span>, not cluster name.         |</span><br><span class="line">  | * delay                                                                             |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> waiting <span class="keyword">for</span> something to happen.                                   |</span><br><span class="line">  | * discover                                                                          |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> device discovery.                                                  |</span><br><span class="line">  | * groupsettings                                                                     |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> manipulating group keys and memberships <span class="keyword">for</span> chip-tool itself.      |</span><br><span class="line">  | * icd                                                                               |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> client-side ICD management.                                        |</span><br><span class="line">  | * pairing                                                                           |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> commissioning devices.                                             |</span><br><span class="line">  | * payload                                                                           |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> parsing and generating setup payloads.                             |</span><br><span class="line">  | * sessionmanagement                                                                 |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> managing CASE and PASE session state.                              |</span><br><span class="line">  | * subscriptions                                                                     |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> shutting down subscriptions.                                       |</span><br><span class="line">  | * interactive                                                                       |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> starting long-lived interactive modes.                             |</span><br><span class="line">  | * storage                                                                           |</span><br><span class="line">  |   - Commands <span class="keyword">for</span> managing persistent data stored by chip-tool.                      |</span><br><span class="line">  +-------------------------------------------------------------------------------------+</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在交互模式内执行命令为设备配网：<code>pairing ble-wifi 0x7283 CUBEC_AP_2.4G cubec2015 20202021 3840</code>。若设备配网成功，在Terminal A会出现设备设备已获取IP地址，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">I (323035) wifi:&lt;ba-add&gt;idx:1 (ifx:0, <span class="built_in">fc</span>:83:c6:00:8f:ae), tid:6, ssn:1, winSize:64</span><br><span class="line">I (323075) chip[DL]: Confirm received <span class="keyword">for</span> CHIPoBLE TX characteristic indication (con 1) status= 14 </span><br><span class="line">I (323845) esp_netif_handlers: sta ip: 192.168.5.201, mask: 255.255.255.0, gw: 192.168.5.1</span><br><span class="line">I (323845) chip[DL]: IP_EVENT_STA_GOT_IP</span><br><span class="line">I (323855) chip[DL]: IPv4 address changed on WiFi station interface: 192.168.5.201/255.255.255.0 gateway 192.168.5.1</span><br><span class="line">I (323865) chip[DL]: IPv4 Internet connectivity ESTABLISHED</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="控制"><a href="#控制" class="headerlink" title="控制"></a>控制</h2><p>设备配网成功后，接着可以在Terminal B通过chip-tool交互模式内控制设备，例如：打开LED、关闭LED、反转LED、调节亮度、调节颜色</p>
<p><strong>单次执行：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开LED</span></span><br><span class="line">chip-tool onoff on 0x7283 0x1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭LED</span></span><br><span class="line">chip-tool onoff off 0x7283 0x1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转LED</span></span><br><span class="line">chip-tool onoff toggle 0x7283 0x1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调节亮度</span></span><br><span class="line"><span class="comment">## 设置亮度为10%（实际低于30%后,LED就熄灭了）</span></span><br><span class="line">chip-tool levelcontrol move-to-level 10 0 0 0 0x7283 0x1</span><br><span class="line"><span class="comment">## 设置亮度为100%</span></span><br><span class="line">chip-tool levelcontrol move-to-level 100 0 0 0 0x7283 0x1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调节颜色</span></span><br><span class="line"><span class="comment">## 设置暖色调色温</span></span><br><span class="line">chip-tool colorcontrol move-to-color-temperature 500 0 0 0 0x7283 0x1</span><br><span class="line"><span class="comment">## 设置冷色调色温</span></span><br><span class="line">chip-tool colorcontrol move-to-color-temperature 154 0 0 0 0x7283 0x1</span><br></pre></td></tr></table></figure>



<p><strong>交互执行：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打开LED</span></span><br><span class="line">onoff on 0x7283 0x1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭LED</span></span><br><span class="line">onoff off 0x7283 0x1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 反转LED</span></span><br><span class="line">onoff toggle 0x7283 0x1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调节亮度</span></span><br><span class="line"><span class="comment">## 设置亮度为10%（实际低于30%后,LED就熄灭了）</span></span><br><span class="line">levelcontrol move-to-level 10 0 0 0 0x7283 0x1</span><br><span class="line"><span class="comment">## 设置亮度为100%</span></span><br><span class="line">levelcontrol move-to-level 100 0 0 0 0x7283 0x1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调节颜色</span></span><br><span class="line"><span class="comment">## 设置暖色调色温</span></span><br><span class="line">colorcontrol move-to-color-temperature 500 0 0 0 0x7283 0x1</span><br><span class="line"><span class="comment">## 设置冷色调色温</span></span><br><span class="line">colorcontrol move-to-color-temperature 154 0 0 0 0x7283 0x1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.espressif.com/projects/esp-matter/en/latest/esp32c3/developing.html">1、Developing with the SDK of ESP-MATTER</a></p>
]]></content>
      <categories>
        <category>ESP</category>
      </categories>
      <tags>
        <tag>esp-matter</tag>
      </tags>
  </entry>
  <entry>
    <title>Matter：Lighting Device Types</title>
    <url>/2024/08/13/Matter%EF%BC%9ALighting%20Device%20Types/</url>
    <content><![CDATA[<h2 id="Light基础"><a href="#Light基础" class="headerlink" title="Light基础"></a>Light基础</h2><p>色调、饱和度和亮度（hue, saturation, and brightness）以人对红、绿、蓝（RGB）三色组合的感觉为基础。</p>
<ul>
<li>色调（hue）是在可见光光谱中能量最强时的波长</li>
<li>饱和度（saturation）表示可见光的相对带宽</li>
<li>亮度（brightness）表示可见光的能量强度</li>
</ul>
<h2 id="On-Off-Light"><a href="#On-Off-Light" class="headerlink" title="On&#x2F;Off Light"></a>On&#x2F;Off Light</h2><p>On&#x2F;Off Light 是一种照明设备，可以通过绑定控制器设备（例如：普通开关或者调光开关）对其进行打开和关闭，而且，也可通过绑定人体存在传感器来切换。</p>
<p><strong>分类：</strong></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Device Name</th>
<th>Superset</th>
<th>Class</th>
<th>Scope</th>
</tr>
</thead>
<tbody><tr>
<td>0x0100</td>
<td>On&#x2F;Off Light</td>
<td></td>
<td>Simple</td>
<td>Endpoint</td>
</tr>
</tbody></table>
<p><strong>集群：</strong></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Cluster</th>
<th>Client&#x2F;Server</th>
<th>Quality</th>
<th>Conformance</th>
</tr>
</thead>
<tbody><tr>
<td>0x0003</td>
<td>Identify</td>
<td>Server</td>
<td></td>
<td>M</td>
</tr>
<tr>
<td>0x0004</td>
<td>Group</td>
<td>Server</td>
<td></td>
<td>M</td>
</tr>
<tr>
<td>0x0062</td>
<td>Scenes Management</td>
<td>Server</td>
<td></td>
<td>P,M</td>
</tr>
<tr>
<td>0x0006</td>
<td>On&#x2F;Off</td>
<td>Server</td>
<td></td>
<td>M</td>
</tr>
<tr>
<td>0x0008</td>
<td>Level Control</td>
<td>Server</td>
<td></td>
<td>O</td>
</tr>
<tr>
<td>0x0406</td>
<td>Occupancy Sensing</td>
<td>Client</td>
<td></td>
<td>O</td>
</tr>
</tbody></table>
<p>对于 On&#x2F;Off Light 设备的状态只有：on 和 off 两种状态，但标准还是加上了Level Control Cluster，仅仅是方便和其他 Dimmable Light形成组合时，能够接受 On&#x2F;Off 命令。</p>
<p><strong>元素：</strong></p>
<table>
<thead>
<tr>
<th>ID</th>
<th>Cluster</th>
<th>Element</th>
<th>Name</th>
<th>Constraint</th>
<th>Access</th>
<th>Conformance</th>
</tr>
</thead>
<tbody><tr>
<td>0x0003</td>
<td>Identify</td>
<td>Command</td>
<td>TriggerEffect</td>
<td></td>
<td></td>
<td>M</td>
</tr>
<tr>
<td>0x0062</td>
<td>Scenes Management</td>
<td>Command</td>
<td>CopyScene</td>
<td></td>
<td></td>
<td>P,M</td>
</tr>
<tr>
<td>0x0006</td>
<td>On&#x2F;Off</td>
<td>Feature</td>
<td>Lighting</td>
<td></td>
<td></td>
<td>M</td>
</tr>
<tr>
<td>0x0008</td>
<td>Level Control</td>
<td>Feature</td>
<td>OnOff</td>
<td></td>
<td></td>
<td>M</td>
</tr>
<tr>
<td>0x0008</td>
<td>Level Control</td>
<td>Feature</td>
<td>Lighting</td>
<td></td>
<td></td>
<td>M</td>
</tr>
<tr>
<td>0x0008</td>
<td>Level Control</td>
<td>Attribute</td>
<td>CurrentLevel</td>
<td>1 to 254</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x0008</td>
<td>Level Control</td>
<td>Attribute</td>
<td>MinLevel</td>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>0x0008</td>
<td>Level Control</td>
<td>Attribute</td>
<td>MaxLevel</td>
<td>254</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="Dimmable-Light"><a href="#Dimmable-Light" class="headerlink" title="Dimmable Light"></a>Dimmable Light</h2><h2 id="Color-Temperature-Light"><a href="#Color-Temperature-Light" class="headerlink" title="Color Temperature Light"></a>Color Temperature Light</h2><h2 id="Extended-Color-Light"><a href="#Extended-Color-Light" class="headerlink" title="Extended Color Light"></a>Extended Color Light</h2>]]></content>
      <categories>
        <category>Matter</category>
      </categories>
      <tags>
        <tag>Light of Matter Device</tag>
        <tag>matter-1-3-device-library-specification</tag>
      </tags>
  </entry>
  <entry>
    <title>Matter Standard</title>
    <url>/2024/08/13/Matter%20Standard/</url>
    <content><![CDATA[<h2 id="Matter介绍"><a href="#Matter介绍" class="headerlink" title="Matter介绍"></a>Matter介绍</h2><p>市场上对于IoT领域生态有很多，例如：苹果生态（Homekit）、谷歌生态（Weave）、亚马逊生态（Echo）、三星生态、小米生态。设备厂商针对某一个生态生产的设备仅支持这个生态（苹果生态），不能支持其他生态（谷歌生态、三星生态），形成了生态壁垒。</p>
<p><strong>用户：</strong></p>
<p>如果用户使用苹果手机，那么用户只能购买支持苹果生态的IoT设备。一旦用户不在使用苹果手机，而使用谷歌手机，那么支持苹果生态的IoT设备就成了一堆废品。现在用户想使用IoT设备，那么必须再购买支持谷歌生态的IoT设备，对于用户来说，这又是一笔不小的开销。</p>
<p><strong>厂商：</strong></p>
<p>如果厂商生产了支持苹果生态的IoT设备，那么它的目标用户是持有苹果手机的用户。对于同一款产品（例如：色温灯），厂商为了获取更多的用户，就必须开发支持各种生态的产品（例如：色温灯）。对于厂商来说，产品还是那个，只是软件层面的不同，不得不生产支持不同生态的同一款产品，生产成本又是一个的问题。</p>
<p><strong>Matter：</strong></p>
<p>如果厂商生产的IoT产品支持Matter标准，那么对于用户来说，不管你使用的是苹果手机，还是谷歌手机，你都可以将IoT产品添加到你当前的生态中。对于用户，购买的IoT产品适配各种生态，完全不用担心换手机会导致IoT产品无法使用的问题。对于厂商，不用再投入很大的成本去生产支持各种生态的IoT设备，仅需要生产支持Matter标准的IoT产品。</p>
<p>甚至，IoT产品添加到苹果生态后，你还可以将该产品分享给其他生态使用，完全隔绝了生态壁垒。</p>
<p>Matter是由CSA发布的一个应用标准，它的传输是建立在支持IPv6的TCP和UDP协议上的，Matter不对传输层进行约定，Matter也不对网络进行约定，但是Matter约定了只能使用 <em>Thread&#x2F;Wi-Fi&#x2F;Ethernet</em> 三种连接协议，也就是说Matter可以让不同网络中的设备进行互联互通通信，这个主要是指Thread Board Router 可以实现 Wi-Fi 和 Thread 通信互转。不仅如此，Matter还允许接入其他网络设备，比如ZigBee设备，这主要通过一个 <em>Matter bridge</em> 设备来实现。在Matter拓扑结构中，还有一个节点非常重要：<em>Matter controller</em>，Matter controller用来完成配网和远程控制设备，比如苹果的 HomePod mini &amp; Home app 组合就是一个典型的Matter controller节点。</p>
<p>Thread协议由Thread Group制定，所以Matter over Thread产品必须通过Thread Group的认证。Wi-Fi则由Wi-Fi联盟进行规范，所以Matter over Wi-Fi产品必须通过Wi-Fi Alliance认证。</p>
<p><strong>文档：</strong></p>
<p>Matter官方文档（主要有3份）：</p>
<ul>
<li>Matter 1.3 Device Library Specification：对设备层面的一些约束和规定</li>
<li>Matter 1.3 Core Specification：核心规范</li>
<li>Matter 1.3 Application Cluster Specification：对Matter组件Cluster进行了详细规定</li>
</ul>
<p>2024年，Matter最新版本是V1.3，随着Matter的版本更新，文档也会随着更新。</p>
<h2 id="Matter-协议栈"><a href="#Matter-协议栈" class="headerlink" title="Matter 协议栈"></a>Matter 协议栈</h2><h3 id="Data-Model（数据模型）"><a href="#Data-Model（数据模型）" class="headerlink" title="Data Model（数据模型）"></a>Data Model（数据模型）</h3><h4 id="Node（节点）"><a href="#Node（节点）" class="headerlink" title="Node（节点）"></a>Node（节点）</h4><p>节点(Node)是一个逻辑上独立的设备，有自己唯一的网络地址。每个Matter设备由一个或多个Node组成。通常是用户可以识别为整个设备的物理设备，例如色温灯。</p>
<h4 id="Endpoint（端点）"><a href="#Endpoint（端点）" class="headerlink" title="Endpoint（端点）"></a>Endpoint（端点）</h4><p>一个Node包含多个Endpoint，每个endpoint是一个逻辑上独立的功能模块。端点可以看作是提供逻辑分组在一起的虚拟设备。例如色温灯，具备两个Endpoint，其中Endpoint 1是可调光灯，EndPoint 2是开&#x2F;关灯。</p>
<p><em>注意：Endpoint 0 预留给 Matter 的 utility cluster，而且每个 Matter 设备都必须强制包含 Endpoint 0</em></p>
<h4 id="Cluster（集群）"><a href="#Cluster（集群）" class="headerlink" title="Cluster（集群）"></a>Cluster（集群）</h4><p>一个Endpoint由一个或多个cluster组成，cluster可以认为是一个基本功能集，它包含 <em>attributess</em>， <em>commands</em>和 <em>events</em>三个组件。</p>
<p>对于色温灯，其中Endpoint 1是可调光灯，它有两个cluster，分别是：On&#x2F;Off cluster 和 Level Control cluster 。</p>
<p>Matter定义了两种类型的cluster：</p>
<ul>
<li>server：提供Attributes、Commands、Events，通常指 Matter 设备。</li>
<li>client：对server发起交互（interaction）操作，通常指 Matter Controller。</li>
</ul>
<h4 id="attributes（属性）"><a href="#attributes（属性）" class="headerlink" title="attributes（属性）"></a>attributes（属性）</h4><p>属性表示可以读取或写入的内容。</p>
<p>对于色温灯的Endpoint 1，其中On&#x2F;Off cluster 的 attributess 是 OnOff 。</p>
<p>对于色温灯的Endpoint 1，其中Level Control cluster 的 attributess 是 CurrentLevel 。</p>
<h4 id="Command（命令）"><a href="#Command（命令）" class="headerlink" title="Command（命令）"></a>Command（命令）</h4><p>命令提供在集群上调用特定行为的能力。</p>
<p>对于色温灯的Endpoint 1，其中On&#x2F;Off cluster 的 Commands 有：On、Off、Toggle</p>
<p>对于色温灯的Endpoint 1，其中Level Control cluster 的 Commands 有：MoveToLevel 。</p>
<h4 id="Event（事件）"><a href="#Event（事件）" class="headerlink" title="Event（事件）"></a>Event（事件）</h4><p>Event其实是一种特殊的attributes，它用来更新设备的状态。</p>
<h3 id="Interaction-Model（交互模型）"><a href="#Interaction-Model（交互模型）" class="headerlink" title="Interaction Model（交互模型）"></a>Interaction Model（交互模型）</h3><p>通俗地讲，Interaction model就是用来规定交互命令集的，我们把发起交互的节点叫initiator (一般都是client设备)，而接收者称为target (一般为server设备)。</p>
<p>Matter定义了如下interaction类型：</p>
<ul>
<li><strong>Read</strong></li>
</ul>
<p>​	用来读取attributes或events的值</p>
<ul>
<li><strong>Write</strong></li>
</ul>
<p>​	用来修改attribute的值</p>
<ul>
<li><strong>Invoke</strong></li>
</ul>
<p>​	用来发送commands</p>
<ul>
<li><strong>Subscribe</strong></li>
</ul>
<p>​	用来订阅target的数据报告，从而不用定时去查询相关数据，我们可以订阅attribute，也可以订阅event。</p>
<p>Interaction本身由transaction组成，而transaction又由action组成，每个action包含1条或者多条信息。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.espressif.com/what-does-matter-mean-to-you-fa3bb53a7793">What does Matter mean to you?</a></p>
<p><a href="https://blog.espressif.com/matter-clusters-attributess-commands-82b8ec1640a0">Matter: Clusters, attributess, Commands</a></p>
<p><a href="https://mp.weixin.qq.com/s/xU82G0LL-92zd86iXChwKQ">Matter开发，看这一篇就够了</a></p>
]]></content>
      <categories>
        <category>Matter</category>
      </categories>
      <tags>
        <tag>Matter Standard</tag>
        <tag>CSA</tag>
        <tag>IoT</tag>
      </tags>
  </entry>
  <entry>
    <title>ntp application</title>
    <url>/2024/08/12/ntp%20application/</url>
    <content><![CDATA[<h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>ntp</tag>
        <tag>time sync</tag>
      </tags>
  </entry>
  <entry>
    <title>wpa-supplicant application</title>
    <url>/2024/08/12/wpa-supplicant%20application/</url>
    <content><![CDATA[<h2 id="无线热点"><a href="#无线热点" class="headerlink" title="无线热点"></a>无线热点</h2><p>路由器能够建立无线热点，供手机或PC等无线设备上网。无线热点支持IEEE 802.11 b&#x2F;g&#x2F;n 标准可以同时有两个频率选择：2.5GHz 和 5GHz。</p>
<p>无线热点的基本信息：</p>
<ul>
<li><p>网络名称（SSID）<br>  SSID不能唯一的表示一个无线热点，即多个无线热点能设置相同的SSID。<br>  SSID设置广播模式后，其他设置才能搜索到该SSID，否则该SSID被隐藏，只能通过手动输入SSID进行连接。</p>
</li>
<li><p>安全模式<br>  安全模式能设置无线热点的加密类型：OPEN、WPA2(AES)-PSK、WPA-PSK&#x2F;WPA2-PSK</p>
</li>
<li><p>密码（PSK）<br>  密码的有无取决于安全模式。若安全模式为 OPEN，则密码为空；若安全模式为其他类型，则密码不为空。</p>
</li>
</ul>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>wpa_supplicant.conf 作为 wpa_supplicant 应用程序的配置文件，可以持久化保存一些信息。</p>
<p>1、wpa_supplicant.conf 可以设置哪些配置？<br>2、wpa_supplicant.conf 可以保存哪些信息？ </p>
<h3 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl_interface=/var/run/wpa_supplicant</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="保存信息"><a href="#保存信息" class="headerlink" title="保存信息"></a>保存信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ctrl_interface=/var/run/wpa_supplicant</span><br><span class="line">update_config=1</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">	ssid=&quot;ZTE_AP_2.4G&quot;</span><br><span class="line">	scan_ssid=1</span><br><span class="line">	psk=&quot;zte2015&quot;</span><br><span class="line">	priority=1</span><br><span class="line">	disabled=1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network=&#123;</span><br><span class="line">	ssid=&quot;ZTE_5GCPE_F876&quot;</span><br><span class="line">	scan_ssid=1</span><br><span class="line">	key_mgmt=NONE</span><br><span class="line">	priority=2</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>Wi-Fi</category>
      </categories>
      <tags>
        <tag>Wi-Fi</tag>
        <tag>wpa_supplicant</tag>
      </tags>
  </entry>
  <entry>
    <title>Blog deploy to Github Page.md</title>
    <url>/2024/08/11/Blog%20deploy%20to%20Github%20Page/</url>
    <content><![CDATA[<blockquote>
<p>2024-08-11 星期日 晴</p>
</blockquote>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><blockquote>
<p>前置条件：<br>1、本地可以正常运行hexo<br>2、已经安装git<br>3、已经注册了Github账号</p>
</blockquote>
<p>首先需要拿到Github的仓库域名，接着上传本地的公钥到Github</p>
<h3 id="获取域名"><a href="#获取域名" class="headerlink" title="获取域名"></a>获取域名</h3><p>在Github上新建一个仓库，仓库命名：<code>eiSouthBoy.github.io</code>，eiSouthBoy 是用户名，根据自己实际用户名修改，仓库的属性选择：<code>Public</code>，最后点击创建。</p>
<p>此时，在 eiSouthBoy.github.io 仓库页面，进入到仓库的Settings–&gt;Pages，可以看到Github提供的Github Pages，给出了网址：<code>Your site is live at https://eisouthboy.github.io/</code>，可以在浏览器输入网址直接访问的。</p>
<h3 id="上传公钥"><a href="#上传公钥" class="headerlink" title="上传公钥"></a>上传公钥</h3><p>将本地的博客上传到Github上，需要使用Github的写入权限，所以需要将本地用户的公钥上传到Github。</p>
<p>创建公钥前，需要配置git的用户名和邮箱</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入ubuntu22.04容器</span></span><br><span class="line">docker <span class="built_in">exec</span> -it -u cj 52e0bd6293ac /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> /workspace/blog</span><br><span class="line">git config --global user.name=eiSouthBoy</span><br><span class="line">git config --global user.email=caoj97141@gmail.com</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>git用户名和邮箱添加后，此时可以生成公钥了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该命令有交互，默认全部回车即可</span></span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>该命令执行完毕后，提示公钥文件保存的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cj@52e0bd6293ac:/workspace/blog$ ll ~/.ssh/</span><br><span class="line">total 28</span><br><span class="line">drwx------ 2 cj cj 4096 Aug 11 03:53 ./</span><br><span class="line">drwxr-x--- 1 cj cj 4096 Aug 11 07:57 ../</span><br><span class="line">-rw------- 1 cj cj 2602 Aug 11 03:48 id_rsa</span><br><span class="line">-rw-r--r-- 1 cj cj  569 Aug 11 03:48 id_rsa.pub</span><br><span class="line"></span><br><span class="line">``</span><br><span class="line"></span><br><span class="line">将公钥信息上传到Github，即将id_rsa.pub文件内容复制到Github的**github个人图像 --&gt; Settings --&gt; SSH and GPG Keys --&gt; New SSH Key**，点击创建，就会创建SSH Key信息。该信息形式如下所示（为了不保留个人信息，SHA256隐藏了关键信息）：</span><br><span class="line"></span><br><span class="line">```plaintext</span><br><span class="line">cj@52e0bd6293ac</span><br><span class="line">SHA256:*******************************************</span><br><span class="line">Added on Aug 11, 2024</span><br><span class="line">Last used within the last week — Read/write</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试 SSH 是否能连接到 GitHub 的 SSH 服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>

<p>出现如下提示，即说明本地能够通过SSH连接到Github的SSH服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hi eiSouthBoy! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>通过git方式上传博客到Github，还需要下载一个插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>在部署前，必须要修改 <code>/workspace/blog/_config.yml</code> 文件，修改的部分内容有：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改第一处</span></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">https://eisouthboy.github.io</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第二处</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:eiSouthBoy/eiSouthBoy.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在可以部署到Github上了，过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /workspace/blog</span><br><span class="line">hexo clean &amp;&amp; hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>记录 <code>hexo d</code> 命令的返回结果信息 (非首次提交)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cj@52e0bd6293ac:/workspace/blog$ hexo d</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">INFO  Copying files from extend <span class="built_in">dirs</span>...</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line">Enumerating objects: 74, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (74/74), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (29/29), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (43/43), 21.26 KiB | 3.54 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 43 (delta 19), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (19/19), completed with 14 <span class="built_in">local</span> objects.</span><br><span class="line">To github.com:eiSouthBoy/eiSouthBoy.github.io.git</span><br><span class="line">   bbb8d53..60a542a  HEAD -&gt; main</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;main&#x27;</span> from <span class="string">&#x27;git@github.com:eiSouthBoy/eiSouthBoy.github.io.git&#x27;</span>.</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>部署成功后，可以在宿主机的浏览器输入：<code>https://eisouthboy.github.io</code> 访问博客。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>在部署过程中，可能遇到一些报错或者疑点，希望记录下来。用于提醒自己，还可以提醒后来人。</p>
<h3 id="疑点1"><a href="#疑点1" class="headerlink" title="疑点1"></a>疑点1</h3><p>在执行 <code>hexo d</code> 命令时，有一句提醒：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;main&#x27;</span> from <span class="string">&#x27;git@github.com:eiSouthBoy/eiSouthBoy.github.io.git&#x27;</span>.</span><br></pre></td></tr></table></figure>

<p>本地分支 master 建立跟踪在远程分支main上。Github从2020年10月开始，创建仓库的默认分支名：main，至于原因可参考：<a href="https://pages.carm.cc/doc/branch-main.html">为什么Git分支开始从“master”变为“main”了？</a></p>
<p>但是 <code>git init</code> 初始化一个本地仓库时，默认的分支是：<code>master</code>，这就是为什么本地master分支和远程main分支名称不一致的原因了。</p>
<p>当然，我们可以修改本地的master名称，过程如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /workspace/blog/.deploy_git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名</span></span><br><span class="line">git branch -m master main</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分支信息</span></span><br><span class="line">git branch</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是本地分支名已经修改完成了，再次执行部署命令 ，验证一下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cj@52e0bd6293ac:/workspace/blog$ hexo d</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Deploying: git</span><br><span class="line">INFO  Clearing .deploy_git folder...</span><br><span class="line">INFO  Copying files from public folder...</span><br><span class="line">INFO  Copying files from extend <span class="built_in">dirs</span>...</span><br><span class="line">[main 6aa2596] Site updated: 2024-08-11 10:04:48</span><br><span class="line"> 4 files changed, 28 insertions(+), 10 deletions(-)</span><br><span class="line">Enumerating objects: 21, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (21/21), <span class="keyword">done</span>.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (7/7), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (11/11), 3.32 KiB | 1.66 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 11 (delta 5), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (5/5), completed with 5 <span class="built_in">local</span> objects.</span><br><span class="line">To github.com:eiSouthBoy/eiSouthBoy.github.io.git</span><br><span class="line">   60a542a..6aa2596  HEAD -&gt; main</span><br><span class="line">Branch <span class="string">&#x27;main&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;main&#x27;</span> from <span class="string">&#x27;git@github.com:eiSouthBoy/eiSouthBoy.github.io.git&#x27;</span>.</span><br><span class="line">INFO  Deploy <span class="keyword">done</span>: git</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上面的信息，可以看到本地分支名和远程分支名一致了。</p>
]]></content>
      <tags>
        <tag>Github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Create Blog with hexo</title>
    <url>/2024/08/10/Create%20Blog%20with%20hexo/</url>
    <content><![CDATA[<blockquote>
<p>2024-08-10 星期六 晴</p>
</blockquote>
<h2 id="缘起"><a href="#缘起" class="headerlink" title="缘起"></a>缘起</h2><p>在大学时（2015年~2019年），我觉得搭建一个博客很酷的事。虽然觉得很酷，但我仍然没有去实现这个很酷的事。直到三年后，我尝试了去搭建个人博客站点，但是对于我难度确实不小（知识储备不足），失败并搁浅了。</p>
<p>为什么几年后的今天，我又尝试去搭建个人博客呢？ 一方面，我看到博客园近两年来危机不断，而我当初为了寻求方便，所以一直在博客园记录自己的东西。当然，我也希望博客园能尽快走出危机，准备去买一件博客园的周边T恤，权当赞助博客园。但个人能力有限，只能做到这点帮助，最终还是需要博客园找到自己的运营模式，毕竟单纯依靠粉丝支援和赞助只能解决一时困境。另一方面，随着这几年的技术经验的积累，完全有信心把博客搭建起来。<br>鸡蛋不能放在同一个篮子里，在博客园存放一份，Github也要存放一份，当然在本地主机上还是要存放一份。这样子就比较保险了，毕竟数据是无价的。</p>
<h2 id="选型"><a href="#选型" class="headerlink" title="选型"></a>选型</h2><p>搭建博客的方式有很多种，例如：WordPress、huogo、hexo等等。但是我必须寻求一种适合我的搭建方式，我的要求包括：</p>
<ul>
<li>支持markdown<br>  我习惯于了使用markdown写东西，用起来方便、快捷。</li>
<li>简单且易用<br>  我希望能够通过简单的命令行就能够部署起来</li>
<li>支持Github<br>  我有使用Github的习惯，一些学习的项目会上传到Github</li>
<li>开源<br>  我习惯使用开源的东西，支持自定义很多东西</li>
</ul>
<p>经过一段时间的挑选，hexo基本符合我的需求，而且生态也比较好，出现问题也容易解决，我决定使用hexo搭建个人博客站点。	</p>
<h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><blockquote>
<p>搭建环境：<br>1、ubuntu22.04容器<br>2、npm (v8.5.1)<br>3、node (v12.22.9)<br>4、git (v2.34.1)</p>
</blockquote>
<p>我的电脑系统是Ubuntu22.04，并且已经安装了Docker。我不希望hexo的环境影响到我的Ubuntu22.04系统，所以我决定通过Docker创建Ubuntu22.04容器来作为搭建博客的环境。同时，我学习Docker技术的时间也就一周左右，也能通过搭建博客的过程中，加强对Docker的使用和理解，一举两得。</p>
<h3 id="拉取ubuntu22-04镜像"><a href="#拉取ubuntu22-04镜像" class="headerlink" title="拉取ubuntu22.04镜像"></a>拉取ubuntu22.04镜像</h3><p>首先，搜索一下镜像源是否存在ubuntu22.04镜像，可以执行命令： <code>docker search ubuntu:22.04</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">caojun@caojun-NMH-WCX9:~/07-docker$ docker search ubuntu:22.04</span><br><span class="line">NAME                                              DESCRIPTION                                     STARS     OFFICIAL</span><br><span class="line">ubuntu                                            Ubuntu is a Debian-based Linux operating sys…   17202     [OK]</span><br><span class="line">ubuntu-debootstrap                                DEPRECATED; use <span class="string">&quot;ubuntu&quot;</span> instead                52        [OK]</span><br><span class="line">ubuntu-upstart                                    DEPRECATED, as is Upstart (find other proces…   115       [OK]</span><br><span class="line">apache/cassandra-testing-ubuntu2004-java11        https://github.com/apache/cassandra-builds/t…   2         </span><br><span class="line">antrea/antrea-ubuntu-arm64                                                                        2         </span><br><span class="line">osrf/ubuntu_i386                                  Ubuntu i386 Docker Base Images                  2         </span><br><span class="line">istio/app_sidecar_base_ubuntu_xenial              Image <span class="keyword">for</span> testing                               0         </span><br><span class="line">istio/app_sidecar_ubuntu_jammy                    Image <span class="keyword">for</span> testing                               0         </span><br><span class="line">envoyproxy/envoy-build-ubuntu                                                                     7         </span><br><span class="line">eclipse/ubuntu_jdk8                               Ubuntu, JDK8, Maven 3, git, curl, nmap, mc, …   17        </span><br><span class="line">osrf/ubuntu_arm64                                 Ubuntu Arm64 Base Images                        1         </span><br><span class="line">dokken/ubuntu-20.04                               Ubuntu 20.04 image <span class="keyword">for</span> use with Test Kitchen…   3         </span><br><span class="line">opensciencegrid/osgvo-ubuntu-18.04                OSG VO<span class="string">&#x27;s base Ubuntu 18.04 image                0         </span></span><br><span class="line"><span class="string">dokken/ubuntu-18.04                               Ubuntu 18.04 image for use with Test Kitchen…   5         </span></span><br><span class="line"><span class="string">fnndsc/ubuntu-python3                             A slim Ubuntu-based Python3 image               33        </span></span><br><span class="line"><span class="string">apache/cassandra-ubuntu2004_test                  Apache Cassandra                                0         </span></span><br><span class="line"><span class="string">jenkinsciinfra/jenkins-agent-ubuntu-20.04         &quot;All-in-one&quot; agent image for the Jenkins Inf…   1         </span></span><br><span class="line"><span class="string">antrea/ubuntu                                                                                     1         </span></span><br><span class="line"><span class="string">dokken/ubuntu-22.04                               Ubuntu 22.04 image for use with Test Kitchen…   3         </span></span><br><span class="line"><span class="string">antrea/base-ubuntu                                                                                1         </span></span><br><span class="line"><span class="string">ubuntu/cortex                                     Cortex provides storage for Prometheus. Long…   4         </span></span><br><span class="line"><span class="string">jenkinsciinfra/jenkins-agent-ubuntu-22.04         &quot;All-in-one&quot; agent image for the Jenkins Inf…   0         </span></span><br><span class="line"><span class="string">gmao/ubuntu20-geos-env                                                                            0         </span></span><br><span class="line"><span class="string">dokken/ubuntu-16.04                               Ubuntu 16.04 image for use with Test Kitchen…   2         </span></span><br><span class="line"><span class="string">pytorch/pytorch-binary-docker-image-ubuntu16.04                                                   6    </span></span><br></pre></td></tr></table></figure>

<p>从上面的信息，可以看到镜像源包括了：ubuntu:18.04 、ubuntu:20.04 、ubuntu:22.04。直接拉取镜像到本地，执行命令： <code>docker pull ubuntu22.04</code><br>拉取成功后，可以在本地查看所有镜像，执行命令：<code>docker images</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">caojun@caojun-NMH-WCX9:~/07-docker$ docker images</span><br><span class="line">REPOSITORY    TAG       IMAGE ID       CREATED         SIZE</span><br><span class="line">ubuntu        22.04     8a3cdc4d1ad3   6 weeks ago     77.9MB</span><br><span class="line">ubuntu        20.04     5f5250218d28   2 months ago    72.8MB</span><br><span class="line">hello-world   latest    d2c94e258dcb   15 months ago   13.3kB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过上述的信息，可以看到拉取的ubuntu22.04镜像只有77.9MB。很多基础工具软件都没有，所以有必要安装并配置一下基础环境，但是先要宿主机上配置一些东西。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为了容器映射卷，创建一个文件夹</span></span><br><span class="line"><span class="built_in">mkdir</span> -p ~/07-docker/blog-ubuntu22_04</span><br><span class="line"><span class="built_in">cd</span> ~/07-docker/blog-ubuntu22_04</span><br><span class="line"></span><br><span class="line"><span class="comment"># 宿主机防火墙开放8110端口，先查一下8110端口是否被占用</span></span><br><span class="line"><span class="comment"># 若没有被占用，就用8110来做映射</span></span><br><span class="line">netstat -ap | grep 8110</span><br><span class="line"></span><br><span class="line"><span class="comment"># 防火墙开放8110</span></span><br><span class="line">ufw <span class="built_in">enable</span></span><br><span class="line">ufw allow 8110</span><br><span class="line">ufw status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并运行容器，image_id=8a3cdc4d1ad3</span></span><br><span class="line">docker run -itd -p 127.0.0.1:8110:4000 -e LANG=C.utf8 -e LC_ALL=C.utf8 --restart=always -v <span class="variable">$PWD</span>:/workspace -u 1000 --security-opt seccomp=unconfined 8a3cdc4d1ad3</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>完成宿主机上的一些基本配置后，可以进入ubuntu22.04容器配置环境了。首次进入ubuntu22.04容器还是要把基础环境搭起来，不然使用起来很不方便。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入ubuntu22.04容器，container_id=52e0bd6293ac</span></span><br><span class="line">docker <span class="built_in">exec</span> -it -u root 52e0bd6293ac /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为root用户创建密码</span></span><br><span class="line">passwd root</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建普通用户cj</span></span><br><span class="line">useradd -u 1000 -m -s /usr/bin/bash cj</span><br><span class="line">passwd cj</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到普通用户cj</span></span><br><span class="line">su cj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新apt源和升级本地软件包</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt upgrade</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装基础工具软件</span></span><br><span class="line"><span class="built_in">sudo</span> apt install -y git net-tools iputils-ping build-essential vim <span class="built_in">sudo</span> curl</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面基本环境搭建起来后，发现有两个小问题：</p>
<ul>
<li>cj用户无法使用sudo</li>
<li>git命令无法自动补全</li>
</ul>
<p><strong>解决第一个问题：</strong></p>
<p>在 <code>/etc/sudoers</code> 文件中，把cj的权限添加进去，对于整个文件仅新增一行即可。<br>由于 <code>/etc/sudoers</code> 文件的权限是：440，所以先修改文件权限才能修改文件，执行命令：<code>sudo chmod 640 /etc/sudoers</code></p>
<p>打开文件，执行：<code>vim /etc/sudoers</code>，新增一行：<code>cj	ALL=(ALL:ALL) ALL</code>，给出修改后的部分内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 省略...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># User privilege specification</span></span><br><span class="line">root	ALL=(ALL:ALL) ALL</span><br><span class="line">cj	ALL=(ALL:ALL) ALL</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 省略...</span></span><br></pre></td></tr></table></figure>

<p>修改并保存文件，需要将该文件的权限修改回来，执行命令：<code>sudo chmod 440 /etc/sudoers</code></p>
<p><strong>解决第二个问题：</strong></p>
<p>ubuntu22.04容器没有激活git的自动补全脚本，所以git相关的命令都无法自动补全。<br>激活git自动补全脚本，执行命令：<code>source /usr/share/bash-completion/completions/git</code></p>
<p>至此，ubuntu22.04容器的基本环境准备完成了，可以进入到下一步。</p>
<h3 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h3><p>安装hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新apt源</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载hexo的依赖包</span></span><br><span class="line"><span class="built_in">sudo</span> apt intall node npm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载hexo</span></span><br><span class="line"><span class="built_in">sudo</span> npm install -g hexo-cli</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>hexo安装完成后，可以查看版本，执行命令：<code>hexo -v</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cj@52e0bd6293ac:/workspace/blog$ hexo -v</span><br><span class="line">INFO  Validating config</span><br><span class="line">hexo: 7.3.0</span><br><span class="line">hexo-cli: 4.3.2</span><br><span class="line">os: linux 6.5.0-45-generic Ubuntu 22.04.4 LTS 22.04.4 LTS (Jammy Jellyfish)</span><br><span class="line">node: 12.22.9</span><br><span class="line">v8: 7.8.279.23-node.56</span><br><span class="line">uv: 1.43.0</span><br><span class="line">zlib: 1.2.11</span><br><span class="line">brotli: 1.0.9</span><br><span class="line">ares: 1.18.1</span><br><span class="line">modules: 72</span><br><span class="line">nghttp2: 1.43.0</span><br><span class="line">napi: 8</span><br><span class="line">llhttp: 2.1.6</span><br><span class="line">http_parser: 2.9.4</span><br><span class="line">openssl: 1.1.1m</span><br><span class="line">cldr: 40.0</span><br><span class="line">icu: 70.1</span><br><span class="line">tz: 2021a3</span><br><span class="line">unicode: 14.0</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>通过hexo初始化一个博客站点，在本地运行博客站点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为博客创建根目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /workspace/blog</span><br><span class="line"><span class="built_in">cd</span> /workspace/blog</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化博客</span></span><br><span class="line">hexo init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行博客，可以通过参数-p指定端口，默认端口是4000</span></span><br><span class="line">hexo s</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在执行：<code>hexo s</code> 时会失败，提示如下报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% extends ‘_layout.swig‘ %&#125; &#123;% import ‘_macro/post.swig‘ as post_template %&#125;</span><br></pre></td></tr></table></figure>

<p>经过在网上查找，发现hexo缺少了swig模块，现在将该模块下载到本地</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /workspace/blog</span><br><span class="line">npm i hexo-renderer-swig</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>再次运行博客，可以看下如下提示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cj@52e0bd6293ac:/workspace/blog$ hexo s</span><br><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN  ========================= ATTENTION! ==========================</span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN   NexT repository is moving here: https://github.com/theme-next </span><br><span class="line">WARN  ===============================================================</span><br><span class="line">WARN   It<span class="string">&#x27;s rebase to v6.0.0 and future maintenance will resume there</span></span><br><span class="line"><span class="string">WARN  ===============================================================</span></span><br><span class="line"><span class="string">INFO  Hexo is running at http://localhost:4000/ . Press Ctrl+C to stop.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>

<p>此时已经成功了，可以在ubuntu22.04容器内访问：<code>http://localhost:4000/</code>，可以通过curl去访问博客，但是这没法渲染。ubuntu22.04容器又没有浏览器，所以只能通过宿主机的浏览器去访问博客，在创建ubuntu22.04容器时，就已经做了端口映射：<code>-p 127.0.0.1:8110:4000</code>，所以宿主机访问 <code>http://localhost:8110</code> 就是访问ubuntu22.04容器 <code>http://localhost:4000</code>。所以，直接在宿主机的浏览器地址栏输入：<code>http://localhost:8110</code> 即可看到博客内容。</p>
<p>至此，在ubuntu22.04容器上基于hexo搭建个人博客就完成了。后续还会修改博客的主题（选择：next主题），并对next主题自定义修改，以及部署到Github。</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>Blog</tag>
        <tag>hexo-theme-next</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2024/08/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
